<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>bstring: bstrlib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">bstring
   &#160;<span id="projectnumber">0.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_290bd8d1f1bf4a1cedefb2564c454673.html">bstring</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bstrlib.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C implementaion of bstring functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdarg.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
</div>
<p><a href="bstrlib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtagbstring.html">tagbstring</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbstrList.html">bstrList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1b611a7f5736a2243f21ea9904f3a24d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b611a7f5736a2243f21ea9904f3a24d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BSTR_PUBLIC</b></td></tr>
<tr class="separator:a1b611a7f5736a2243f21ea9904f3a24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d99b38042ec658a0dbc2ba74249ab2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d99b38042ec658a0dbc2ba74249ab2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BSTR_PRIVATE</b></td></tr>
<tr class="separator:a24d99b38042ec658a0dbc2ba74249ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3fe50ff0ac4d1f76c07c46ee2eeea7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef3fe50ff0ac4d1f76c07c46ee2eeea7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BSTR_PRINTF</b>(format, argument)</td></tr>
<tr class="separator:aef3fe50ff0ac4d1f76c07c46ee2eeea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad35e0c4026b268b9f6762ee7b870212"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad35e0c4026b268b9f6762ee7b870212"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BSTR_UNUSED</b></td></tr>
<tr class="separator:aad35e0c4026b268b9f6762ee7b870212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43a5702c6ca15d82b534df927b7ecc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab43a5702c6ca15d82b534df927b7ecc5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BSTR_ERR</b>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:ab43a5702c6ca15d82b534df927b7ecc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fdf5a39e1c0a01a357f4dc0ef53365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4fdf5a39e1c0a01a357f4dc0ef53365"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BSTR_OK</b>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ae4fdf5a39e1c0a01a357f4dc0ef53365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6fb51cdc569b881c4940be5bb6788c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c6fb51cdc569b881c4940be5bb6788c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BSTR_BS_BUFF_LENGTH_GET</b>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:a3c6fb51cdc569b881c4940be5bb6788c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b0964712a711ab2e1be0ed1caeae49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1b0964712a711ab2e1be0ed1caeae49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>cstr2bstr</b>&#160;&#160;&#160;<a class="el" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a></td></tr>
<tr class="separator:ac1b0964712a711ab2e1be0ed1caeae49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab243648d3d35096c9a9fc8d573d6827"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aab243648d3d35096c9a9fc8d573d6827">bstrchr</a>(b, c)&#160;&#160;&#160;<a class="el" href="bstrlib_8h.html#a26209ea604a59389a452ad1c02f24c40">bstrchrp</a>((b), (c), 0)</td></tr>
<tr class="separator:aab243648d3d35096c9a9fc8d573d6827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56057bf0b9c17ba18bc47135ed5eb2c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a56057bf0b9c17ba18bc47135ed5eb2c1">bstrrchr</a>(b, c)&#160;&#160;&#160;<a class="el" href="bstrlib_8h.html#a7f3e67d89be749a1d2e5ffede2d6f29c">bstrrchrp</a>((b), (c), <a class="el" href="bstrlib_8h.html#a462176ab60e31a2ead1b575b50b1124d">blength</a>(b) - 1)</td></tr>
<tr class="separator:a56057bf0b9c17ba18bc47135ed5eb2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1682c36488d56476284d722c0fabab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#afa1682c36488d56476284d722c0fabab">bvformata</a>(ret, b, fmt, lastarg)</td></tr>
<tr class="separator:afa1682c36488d56476284d722c0fabab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3759bb27b16d4ed7f87d84eb36a64a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a1b3759bb27b16d4ed7f87d84eb36a64a">blengthe</a>(b, e)</td></tr>
<tr class="separator:a1b3759bb27b16d4ed7f87d84eb36a64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462176ab60e31a2ead1b575b50b1124d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a462176ab60e31a2ead1b575b50b1124d">blength</a>(b)&#160;&#160;&#160;(<a class="el" href="bstrlib_8h.html#a1b3759bb27b16d4ed7f87d84eb36a64a">blengthe</a>((b), 0))</td></tr>
<tr class="separator:a462176ab60e31a2ead1b575b50b1124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a17cc3f91a96c0c81f8c2032610a26f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a7a17cc3f91a96c0c81f8c2032610a26f">bdataofse</a>(b, o, e)</td></tr>
<tr class="separator:a7a17cc3f91a96c0c81f8c2032610a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6becf2b45df687b618d745990b77846"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ae6becf2b45df687b618d745990b77846">bdataofs</a>(b, o)&#160;&#160;&#160;(<a class="el" href="bstrlib_8h.html#a7a17cc3f91a96c0c81f8c2032610a26f">bdataofse</a>((b),(o),(void *)0))</td></tr>
<tr class="separator:ae6becf2b45df687b618d745990b77846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319493bef0d51c2d8f4214b30ca0846d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a319493bef0d51c2d8f4214b30ca0846d">bdatae</a>(b, e)&#160;&#160;&#160;(<a class="el" href="bstrlib_8h.html#a7a17cc3f91a96c0c81f8c2032610a26f">bdataofse</a>(b, 0, e))</td></tr>
<tr class="separator:a319493bef0d51c2d8f4214b30ca0846d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918e84c6f0ed26acc34882115e1bc896"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a918e84c6f0ed26acc34882115e1bc896">bdata</a>(b)&#160;&#160;&#160;(<a class="el" href="bstrlib_8h.html#ae6becf2b45df687b618d745990b77846">bdataofs</a>(b, 0))</td></tr>
<tr class="separator:a918e84c6f0ed26acc34882115e1bc896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69796c26dc7f9831420c76f646a1e2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aa69796c26dc7f9831420c76f646a1e2c">bchare</a>(b, p, e)</td></tr>
<tr class="separator:aa69796c26dc7f9831420c76f646a1e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5203b5518eb6a79911185ad22fad42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a7d5203b5518eb6a79911185ad22fad42">bchar</a>(b, p)&#160;&#160;&#160;<a class="el" href="bstrlib_8h.html#aa69796c26dc7f9831420c76f646a1e2c">bchare</a>((b), (p), '\0')</td></tr>
<tr class="separator:a7d5203b5518eb6a79911185ad22fad42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50416729c32d71400fc06201c4a01f5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50416729c32d71400fc06201c4a01f5d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>bsStaticMlen</b>(q, m)&#160;&#160;&#160;{ (m), (int)sizeof(q) - 1, (unsigned char *)(&quot;&quot; q &quot;&quot;) }</td></tr>
<tr class="separator:a50416729c32d71400fc06201c4a01f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41300b1616e4c66c3a2e03479d64bd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab41300b1616e4c66c3a2e03479d64bd9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>bsStatic</b>(q)&#160;&#160;&#160;bsStaticMlen(q, -__LINE__)</td></tr>
<tr class="separator:ab41300b1616e4c66c3a2e03479d64bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc1cdd273f7d9edb89f6a4a49cb852"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ac3dc1cdd273f7d9edb89f6a4a49cb852">bsStaticBlkParms</a>(q)&#160;&#160;&#160;((void *)(&quot;&quot; q &quot;&quot;)), ((int)sizeof(q) -1)</td></tr>
<tr class="separator:ac3dc1cdd273f7d9edb89f6a4a49cb852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696d493c160c150928633ab4c880257b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a696d493c160c150928633ab4c880257b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>cstr2tbstr</b>&#160;&#160;&#160;<a class="el" href="bstrlib_8h.html#a52bfb9d7cacb9f51e42066e2fe3e5a99">btfromcstr</a></td></tr>
<tr class="separator:a696d493c160c150928633ab4c880257b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bfb9d7cacb9f51e42066e2fe3e5a99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a52bfb9d7cacb9f51e42066e2fe3e5a99">btfromcstr</a>(t, s)</td></tr>
<tr class="separator:a52bfb9d7cacb9f51e42066e2fe3e5a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb8d7713b3e5c45ec688b0adcb012f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>blk2tbstr</b>(t, s, l)</td></tr>
<tr class="separator:a8fb8d7713b3e5c45ec688b0adcb012f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f4ba9c4ffa4800e7214ed13d1ae81c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aa6f4ba9c4ffa4800e7214ed13d1ae81c">btfromblk</a>(t, s, l)&#160;&#160;&#160;blk2tbstr(t, s, l)</td></tr>
<tr class="separator:aa6f4ba9c4ffa4800e7214ed13d1ae81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef11b11882ddf92fc7ab44b6d5f3a80d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aef11b11882ddf92fc7ab44b6d5f3a80d">bmid2tbstr</a>(t, b, p, l)</td></tr>
<tr class="separator:aef11b11882ddf92fc7ab44b6d5f3a80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168c04182fd97834fbe508fa8c186991"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a168c04182fd97834fbe508fa8c186991">btfromblkltrimws</a>(t, s, l)</td></tr>
<tr class="separator:a168c04182fd97834fbe508fa8c186991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9590d06aa5bc93a8031d5bbaccf75373"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a9590d06aa5bc93a8031d5bbaccf75373">btfromblkrtrimws</a>(t, s, l)</td></tr>
<tr class="separator:a9590d06aa5bc93a8031d5bbaccf75373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e9e949494d2c5d3f8749b48685e5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#afa5e9e949494d2c5d3f8749b48685e5d">btfromblktrimws</a>(t, s, l)</td></tr>
<tr class="separator:afa5e9e949494d2c5d3f8749b48685e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9759ad92b645976d14692362f2ed10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a3b9759ad92b645976d14692362f2ed10">bwriteprotect</a>(t)</td></tr>
<tr class="separator:a3b9759ad92b645976d14692362f2ed10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e39e69cf2035b12da65078eb1b9817"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a20e39e69cf2035b12da65078eb1b9817">bwriteallow</a>(t)</td></tr>
<tr class="separator:a20e39e69cf2035b12da65078eb1b9817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f90b293b8f88607ae83c2feae7ae99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ae6f90b293b8f88607ae83c2feae7ae99">biswriteprotected</a>(t)&#160;&#160;&#160;((t).mlen &lt;= 0)</td></tr>
<tr class="separator:ae6f90b293b8f88607ae83c2feae7ae99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7ee510452ae810b71268dfa7b39a3712"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ee510452ae810b71268dfa7b39a3712"></a>
typedef struct <a class="el" href="structtagbstring.html">tagbstring</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>bstring</b></td></tr>
<tr class="separator:a7ee510452ae810b71268dfa7b39a3712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a78a95fbcbf5b1c509dc429f145f8d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a78a95fbcbf5b1c509dc429f145f8d9"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>bNgetc</b> )(void *parm)</td></tr>
<tr class="separator:a8a78a95fbcbf5b1c509dc429f145f8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ef9d331039fb01b261388f7265d0d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57ef9d331039fb01b261388f7265d0d6"></a>
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>bNread</b> )(void *buff, size_t elsize, size_t nelem, void *parm)</td></tr>
<tr class="separator:a57ef9d331039fb01b261388f7265d0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a18bcf0b649f36e9023a20cf42d5eb375"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a> (const char *str)</td></tr>
<tr class="separator:a18bcf0b649f36e9023a20cf42d5eb375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ccc3632116698a0dd443dd1e4b0d5d"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a55ccc3632116698a0dd443dd1e4b0d5d">bfromcstralloc</a> (int mlen, const char *str)</td></tr>
<tr class="separator:a55ccc3632116698a0dd443dd1e4b0d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fe48dc5f5d956651f8271e77714df5"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a74fe48dc5f5d956651f8271e77714df5">blk2bstr</a> (const void *blk, int len)</td></tr>
<tr class="separator:a74fe48dc5f5d956651f8271e77714df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8333d17de053dc35dc306ff347c4a167"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a8333d17de053dc35dc306ff347c4a167">bstr2cstr</a> (const <a class="el" href="structtagbstring.html">bstring</a> s, char z)</td></tr>
<tr class="separator:a8333d17de053dc35dc306ff347c4a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f493957027d9cb58a87dbe611975564"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a3f493957027d9cb58a87dbe611975564">bcstrfree</a> (char *s)</td></tr>
<tr class="separator:a3f493957027d9cb58a87dbe611975564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9a9d2432e61127eb204c0bffbb7133"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a8f9a9d2432e61127eb204c0bffbb7133">bstrcpy</a> (const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:a8f9a9d2432e61127eb204c0bffbb7133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03204f69b283e7b069fa2655b959b7c8"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a03204f69b283e7b069fa2655b959b7c8">bassign</a> (<a class="el" href="structtagbstring.html">bstring</a> a, const <a class="el" href="structtagbstring.html">bstring</a> b)</td></tr>
<tr class="separator:a03204f69b283e7b069fa2655b959b7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac41f39c29a40d34ea5342b027719a49"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aac41f39c29a40d34ea5342b027719a49">bassignmidstr</a> (<a class="el" href="structtagbstring.html">bstring</a> a, const <a class="el" href="structtagbstring.html">bstring</a> b, int left, int len)</td></tr>
<tr class="separator:aac41f39c29a40d34ea5342b027719a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794183c3f291f4a990028353ce721a9c"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a794183c3f291f4a990028353ce721a9c">bassigncstr</a> (<a class="el" href="structtagbstring.html">bstring</a> a, const char *str)</td></tr>
<tr class="separator:a794183c3f291f4a990028353ce721a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d4b984c1780a38cd929c7265af1ec7"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ad5d4b984c1780a38cd929c7265af1ec7">bassignblk</a> (<a class="el" href="structtagbstring.html">bstring</a> a, const void *s, int len)</td></tr>
<tr class="separator:ad5d4b984c1780a38cd929c7265af1ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54df7a3d5fc9b10de67c4ea4adaec8fa"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a54df7a3d5fc9b10de67c4ea4adaec8fa">bdestroy</a> (<a class="el" href="structtagbstring.html">bstring</a> b)</td></tr>
<tr class="separator:a54df7a3d5fc9b10de67c4ea4adaec8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ff6de70096458f580242a5c40cdd6"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#af67ff6de70096458f580242a5c40cdd6">balloc</a> (<a class="el" href="structtagbstring.html">bstring</a> s, int len)</td></tr>
<tr class="separator:af67ff6de70096458f580242a5c40cdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f1998603f26df1ee66ebebc370d403"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a25f1998603f26df1ee66ebebc370d403">ballocmin</a> (<a class="el" href="structtagbstring.html">bstring</a> b, int len)</td></tr>
<tr class="separator:a25f1998603f26df1ee66ebebc370d403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5134b739729cb0a2fc2111e53a1d727a"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a5134b739729cb0a2fc2111e53a1d727a">bmidstr</a> (const <a class="el" href="structtagbstring.html">bstring</a> b, int left, int len)</td></tr>
<tr class="separator:a5134b739729cb0a2fc2111e53a1d727a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344d26e5127bb1022debe55a53b20f70"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a344d26e5127bb1022debe55a53b20f70">bconcat</a> (<a class="el" href="structtagbstring.html">bstring</a> b0, const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:a344d26e5127bb1022debe55a53b20f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659957485042fd8954abdcab51f30479"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a659957485042fd8954abdcab51f30479">bconchar</a> (<a class="el" href="structtagbstring.html">bstring</a> b0, char c)</td></tr>
<tr class="separator:a659957485042fd8954abdcab51f30479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab64bb6f143468a52577081ee438edbc"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aab64bb6f143468a52577081ee438edbc">bcatcstr</a> (<a class="el" href="structtagbstring.html">bstring</a> b, const char *s)</td></tr>
<tr class="separator:aab64bb6f143468a52577081ee438edbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e247b5c21799751f25f3edaaf3842e"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a78e247b5c21799751f25f3edaaf3842e">bcatblk</a> (<a class="el" href="structtagbstring.html">bstring</a> b, const void *s, int len)</td></tr>
<tr class="separator:a78e247b5c21799751f25f3edaaf3842e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d94781f02d5a220b3f1da9225916ff"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#af4d94781f02d5a220b3f1da9225916ff">binsert</a> (<a class="el" href="structtagbstring.html">bstring</a> s1, int pos, const <a class="el" href="structtagbstring.html">bstring</a> s2, unsigned char fill)</td></tr>
<tr class="separator:af4d94781f02d5a220b3f1da9225916ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e719f952bf0b19e210a46f4df0ff95"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ab0e719f952bf0b19e210a46f4df0ff95">binsertch</a> (<a class="el" href="structtagbstring.html">bstring</a> s1, int pos, int len, unsigned char fill)</td></tr>
<tr class="separator:ab0e719f952bf0b19e210a46f4df0ff95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121e928e62bc7a8fafbfcb899422473b"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a121e928e62bc7a8fafbfcb899422473b">breplace</a> (<a class="el" href="structtagbstring.html">bstring</a> b1, int pos, int len, const <a class="el" href="structtagbstring.html">bstring</a> b2, unsigned char fill)</td></tr>
<tr class="separator:a121e928e62bc7a8fafbfcb899422473b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4345c14c3bd03532e3eab3cad2397f0c"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a4345c14c3bd03532e3eab3cad2397f0c">bdelete</a> (<a class="el" href="structtagbstring.html">bstring</a> s1, int pos, int len)</td></tr>
<tr class="separator:a4345c14c3bd03532e3eab3cad2397f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e08bbf1ea2ba29c6a4aea6e22d4aa2b"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a9e08bbf1ea2ba29c6a4aea6e22d4aa2b">bsetstr</a> (<a class="el" href="structtagbstring.html">bstring</a> b0, int pos, const <a class="el" href="structtagbstring.html">bstring</a> b1, unsigned char fill)</td></tr>
<tr class="separator:a9e08bbf1ea2ba29c6a4aea6e22d4aa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a8464aba37a4b8a1ff20b9969798af"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a91a8464aba37a4b8a1ff20b9969798af">btrunc</a> (<a class="el" href="structtagbstring.html">bstring</a> b, int n)</td></tr>
<tr class="separator:a91a8464aba37a4b8a1ff20b9969798af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87ba679b2cf2796b412e77d9db153c"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a8b87ba679b2cf2796b412e77d9db153c">bstricmp</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:a8b87ba679b2cf2796b412e77d9db153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e904639bb6ff4caba5696d697460c8d"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a1e904639bb6ff4caba5696d697460c8d">bstrnicmp</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, const <a class="el" href="structtagbstring.html">bstring</a> b1, int n)</td></tr>
<tr class="separator:a1e904639bb6ff4caba5696d697460c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c60e43cf81fd05d7233806b898aa1c"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ac8c60e43cf81fd05d7233806b898aa1c">biseqcaseless</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:ac8c60e43cf81fd05d7233806b898aa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6abf7ef0b3e5d8d0d89f5e23979bf1"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ace6abf7ef0b3e5d8d0d89f5e23979bf1">bisstemeqcaselessblk</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, const void *blk, int len)</td></tr>
<tr class="separator:ace6abf7ef0b3e5d8d0d89f5e23979bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b4e2aeaaeec2848dac58a98be96fca"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a97b4e2aeaaeec2848dac58a98be96fca">biseq</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:a97b4e2aeaaeec2848dac58a98be96fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a399414ee20f508215c38c7df5a193"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a04a399414ee20f508215c38c7df5a193">bisstemeqblk</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, const void *blk, int len)</td></tr>
<tr class="separator:a04a399414ee20f508215c38c7df5a193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fdf5fc281ccc8f5f78ceb581ab95fc"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a63fdf5fc281ccc8f5f78ceb581ab95fc">biseqcstr</a> (const <a class="el" href="structtagbstring.html">bstring</a> b, const char *s)</td></tr>
<tr class="separator:a63fdf5fc281ccc8f5f78ceb581ab95fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadaaf55f6c0f00b5b2a3aef06f21eb97"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aadaaf55f6c0f00b5b2a3aef06f21eb97">biseqcstrcaseless</a> (const <a class="el" href="structtagbstring.html">bstring</a> b, const char *s)</td></tr>
<tr class="separator:aadaaf55f6c0f00b5b2a3aef06f21eb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c60dfeb06b3dc86a00a81da00474ca0"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a1c60dfeb06b3dc86a00a81da00474ca0">bstrcmp</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:a1c60dfeb06b3dc86a00a81da00474ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc2d64746f37d59ca588a569339a670"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aecc2d64746f37d59ca588a569339a670">bstrncmp</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, const <a class="el" href="structtagbstring.html">bstring</a> b1, int n)</td></tr>
<tr class="separator:aecc2d64746f37d59ca588a569339a670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e75dc6bc508a9f35e5b0864b28fecd"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#af8e75dc6bc508a9f35e5b0864b28fecd">binstr</a> (const <a class="el" href="structtagbstring.html">bstring</a> s1, int pos, const <a class="el" href="structtagbstring.html">bstring</a> s2)</td></tr>
<tr class="separator:af8e75dc6bc508a9f35e5b0864b28fecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2980cb23f483902859897017d80d599b"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a2980cb23f483902859897017d80d599b">binstrr</a> (const <a class="el" href="structtagbstring.html">bstring</a> s1, int pos, const <a class="el" href="structtagbstring.html">bstring</a> s2)</td></tr>
<tr class="separator:a2980cb23f483902859897017d80d599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c741078241e60bfe2caaf3427a97d77"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a5c741078241e60bfe2caaf3427a97d77">binstrcaseless</a> (const <a class="el" href="structtagbstring.html">bstring</a> s1, int pos, const <a class="el" href="structtagbstring.html">bstring</a> s2)</td></tr>
<tr class="separator:a5c741078241e60bfe2caaf3427a97d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c09ddbed79e6be9b54a0df8a143a327"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a0c09ddbed79e6be9b54a0df8a143a327">binstrrcaseless</a> (const <a class="el" href="structtagbstring.html">bstring</a> s1, int pos, const <a class="el" href="structtagbstring.html">bstring</a> s2)</td></tr>
<tr class="separator:a0c09ddbed79e6be9b54a0df8a143a327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26209ea604a59389a452ad1c02f24c40"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a26209ea604a59389a452ad1c02f24c40">bstrchrp</a> (const <a class="el" href="structtagbstring.html">bstring</a> b, int c, int pos)</td></tr>
<tr class="separator:a26209ea604a59389a452ad1c02f24c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3e67d89be749a1d2e5ffede2d6f29c"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a7f3e67d89be749a1d2e5ffede2d6f29c">bstrrchrp</a> (const <a class="el" href="structtagbstring.html">bstring</a> b, int c, int pos)</td></tr>
<tr class="separator:a7f3e67d89be749a1d2e5ffede2d6f29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18ed003f2c77ae2fed30cb7cd3ca932"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ad18ed003f2c77ae2fed30cb7cd3ca932">binchr</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, int pos, const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:ad18ed003f2c77ae2fed30cb7cd3ca932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647b29e54d24d416aef212a06df93d84"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a647b29e54d24d416aef212a06df93d84">binchrr</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, int pos, const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:a647b29e54d24d416aef212a06df93d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ee9be8c6a2145f819ecf2a31f0bff8"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ae2ee9be8c6a2145f819ecf2a31f0bff8">bninchr</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, int pos, const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:ae2ee9be8c6a2145f819ecf2a31f0bff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1c06a048e8ef6710e7e4142f8ab9ae"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a5d1c06a048e8ef6710e7e4142f8ab9ae">bninchrr</a> (const <a class="el" href="structtagbstring.html">bstring</a> b0, int pos, const <a class="el" href="structtagbstring.html">bstring</a> b1)</td></tr>
<tr class="separator:a5d1c06a048e8ef6710e7e4142f8ab9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d6e07b000086ff0a8e2b4921305a74"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a92d6e07b000086ff0a8e2b4921305a74">bfindreplace</a> (<a class="el" href="structtagbstring.html">bstring</a> b, const <a class="el" href="structtagbstring.html">bstring</a> find, const <a class="el" href="structtagbstring.html">bstring</a> repl, int pos)</td></tr>
<tr class="separator:a92d6e07b000086ff0a8e2b4921305a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cdcf157780778de69f0510e8292345"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ab0cdcf157780778de69f0510e8292345">bfindreplacecaseless</a> (<a class="el" href="structtagbstring.html">bstring</a> b, const <a class="el" href="structtagbstring.html">bstring</a> find, const <a class="el" href="structtagbstring.html">bstring</a> repl, int pos)</td></tr>
<tr class="separator:ab0cdcf157780778de69f0510e8292345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8256fd68b32e1f855d8663c2ba9673f"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC struct <a class="el" href="structbstrList.html">bstrList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ac8256fd68b32e1f855d8663c2ba9673f">bstrListCreate</a> (void)</td></tr>
<tr class="separator:ac8256fd68b32e1f855d8663c2ba9673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ce2eab1bc5a9e47dfd27bd33945de6"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ac4ce2eab1bc5a9e47dfd27bd33945de6">bstrListDestroy</a> (struct <a class="el" href="structbstrList.html">bstrList</a> *sl)</td></tr>
<tr class="separator:ac4ce2eab1bc5a9e47dfd27bd33945de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c49a96028195353c1f77da89956374"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a29c49a96028195353c1f77da89956374">bstrListAlloc</a> (struct <a class="el" href="structbstrList.html">bstrList</a> *sl, int msz)</td></tr>
<tr class="separator:a29c49a96028195353c1f77da89956374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc9093af717dc10707db3028b0537ca"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#abfc9093af717dc10707db3028b0537ca">bstrListAllocMin</a> (struct <a class="el" href="structbstrList.html">bstrList</a> *sl, int msz)</td></tr>
<tr class="separator:abfc9093af717dc10707db3028b0537ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dfbbd9ceb54609674f93efb2ef4270"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC struct <a class="el" href="structbstrList.html">bstrList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a09dfbbd9ceb54609674f93efb2ef4270">bsplit</a> (const <a class="el" href="structtagbstring.html">bstring</a> str, unsigned char splitChar)</td></tr>
<tr class="separator:a09dfbbd9ceb54609674f93efb2ef4270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3643d53f502cd0a82601f555b9d793"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC struct <a class="el" href="structbstrList.html">bstrList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a0d3643d53f502cd0a82601f555b9d793">bsplits</a> (const <a class="el" href="structtagbstring.html">bstring</a> str, const <a class="el" href="structtagbstring.html">bstring</a> splitStr)</td></tr>
<tr class="separator:a0d3643d53f502cd0a82601f555b9d793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8901b6979be1225005535b62fcbd43"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC struct <a class="el" href="structbstrList.html">bstrList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ade8901b6979be1225005535b62fcbd43">bsplitstr</a> (const <a class="el" href="structtagbstring.html">bstring</a> str, const <a class="el" href="structtagbstring.html">bstring</a> splitStr)</td></tr>
<tr class="separator:ade8901b6979be1225005535b62fcbd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9503d1b05b9a8a06cb80eeb68425be8"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ac9503d1b05b9a8a06cb80eeb68425be8">bjoin</a> (const struct <a class="el" href="structbstrList.html">bstrList</a> *bl, const <a class="el" href="structtagbstring.html">bstring</a> sep)</td></tr>
<tr class="separator:ac9503d1b05b9a8a06cb80eeb68425be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab171b3a636cbff169c621f411b716ae5"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ab171b3a636cbff169c621f411b716ae5">bsplitcb</a> (const <a class="el" href="structtagbstring.html">bstring</a> str, unsigned char splitChar, int pos, int(*cb)(void *parm, int ofs, int len), void *parm)</td></tr>
<tr class="separator:ab171b3a636cbff169c621f411b716ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e0d102ee1fc760655184e1a7fe92bc"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aa7e0d102ee1fc760655184e1a7fe92bc">bsplitscb</a> (const <a class="el" href="structtagbstring.html">bstring</a> str, const <a class="el" href="structtagbstring.html">bstring</a> splitStr, int pos, int(*cb)(void *parm, int ofs, int len), void *parm)</td></tr>
<tr class="separator:aa7e0d102ee1fc760655184e1a7fe92bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c47aea4543afeeb3831656c65bae59"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a88c47aea4543afeeb3831656c65bae59">bsplitstrcb</a> (const <a class="el" href="structtagbstring.html">bstring</a> str, const <a class="el" href="structtagbstring.html">bstring</a> splitStr, int pos, int(*cb)(void *parm, int ofs, int len), void *parm)</td></tr>
<tr class="separator:a88c47aea4543afeeb3831656c65bae59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6ca96a5357fe5723de6bb53c039976"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a0a6ca96a5357fe5723de6bb53c039976">bpattern</a> (<a class="el" href="structtagbstring.html">bstring</a> b, int len)</td></tr>
<tr class="separator:a0a6ca96a5357fe5723de6bb53c039976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636e5fbffa44bb54ca24342eab6ef016"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a636e5fbffa44bb54ca24342eab6ef016">btoupper</a> (<a class="el" href="structtagbstring.html">bstring</a> b)</td></tr>
<tr class="separator:a636e5fbffa44bb54ca24342eab6ef016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471ebb4ce64f26dc634470c787ad0e8a"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a471ebb4ce64f26dc634470c787ad0e8a">btolower</a> (<a class="el" href="structtagbstring.html">bstring</a> b)</td></tr>
<tr class="separator:a471ebb4ce64f26dc634470c787ad0e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5815a4475417b84fde7ee94316f7eb4"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ab5815a4475417b84fde7ee94316f7eb4">bltrimws</a> (<a class="el" href="structtagbstring.html">bstring</a> b)</td></tr>
<tr class="separator:ab5815a4475417b84fde7ee94316f7eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643afd7b892eac5f33da8b6e6ed7a370"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a643afd7b892eac5f33da8b6e6ed7a370">brtrimws</a> (<a class="el" href="structtagbstring.html">bstring</a> b)</td></tr>
<tr class="separator:a643afd7b892eac5f33da8b6e6ed7a370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f230982ef4fc45d8d3b9847fe94802"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ac4f230982ef4fc45d8d3b9847fe94802">btrimws</a> (<a class="el" href="structtagbstring.html">bstring</a> b)</td></tr>
<tr class="separator:ac4f230982ef4fc45d8d3b9847fe94802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8673536cc6151d8486d79f619b9257"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#aed8673536cc6151d8486d79f619b9257">bformat</a> (const char *fmt,...)</td></tr>
<tr class="separator:aed8673536cc6151d8486d79f619b9257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1ba2c8d1deae8c2499114c95b2b745"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a5b1ba2c8d1deae8c2499114c95b2b745">bformata</a> (<a class="el" href="structtagbstring.html">bstring</a> b, const char *fmt,...)</td></tr>
<tr class="separator:a5b1ba2c8d1deae8c2499114c95b2b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740190ec821c74f2c337332727c19183"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a740190ec821c74f2c337332727c19183">bassignformat</a> (<a class="el" href="structtagbstring.html">bstring</a> b, const char *fmt,...)</td></tr>
<tr class="separator:a740190ec821c74f2c337332727c19183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435bf68d7a8ea9a1c73c4b4c3358005"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a6435bf68d7a8ea9a1c73c4b4c3358005">bvcformata</a> (<a class="el" href="structtagbstring.html">bstring</a> b, int count, const char *fmt, va_list arglist)</td></tr>
<tr class="separator:a6435bf68d7a8ea9a1c73c4b4c3358005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6e5799ae68950782222b26bef14fd1"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a9d6e5799ae68950782222b26bef14fd1">bgets</a> (bNgetc getcPtr, void *parm, char terminator)</td></tr>
<tr class="separator:a9d6e5799ae68950782222b26bef14fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d1bab886542a8abc1d441e2d2b669c"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a28d1bab886542a8abc1d441e2d2b669c">bread</a> (bNread readPtr, void *parm)</td></tr>
<tr class="separator:a28d1bab886542a8abc1d441e2d2b669c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f688c14b7a896537f7ade1b825fd988"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a8f688c14b7a896537f7ade1b825fd988">bgetsa</a> (<a class="el" href="structtagbstring.html">bstring</a> b, bNgetc getcPtr, void *parm, char terminator)</td></tr>
<tr class="separator:a8f688c14b7a896537f7ade1b825fd988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8281820fe0c167b0433408e75f140289"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a8281820fe0c167b0433408e75f140289">bassigngets</a> (<a class="el" href="structtagbstring.html">bstring</a> b, bNgetc getcPtr, void *parm, char terminator)</td></tr>
<tr class="separator:a8281820fe0c167b0433408e75f140289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd682527c9a84dfeb91bdbf4e8856ab4"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#abd682527c9a84dfeb91bdbf4e8856ab4">breada</a> (<a class="el" href="structtagbstring.html">bstring</a> b, bNread readPtr, void *parm)</td></tr>
<tr class="separator:abd682527c9a84dfeb91bdbf4e8856ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb96b6b63301b1ebcca743d3089a38af"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC struct bStream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#afb96b6b63301b1ebcca743d3089a38af">bsopen</a> (bNread readPtr, void *parm)</td></tr>
<tr class="separator:afb96b6b63301b1ebcca743d3089a38af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a4b83757a84cd7032f10ec1e7b384c"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ac3a4b83757a84cd7032f10ec1e7b384c">bsclose</a> (struct bStream *s)</td></tr>
<tr class="separator:ac3a4b83757a84cd7032f10ec1e7b384c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9f3dd50c02178eda7af1f17af4d18d"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#acc9f3dd50c02178eda7af1f17af4d18d">bsbufflength</a> (struct bStream *s, int sz)</td></tr>
<tr class="separator:acc9f3dd50c02178eda7af1f17af4d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b80e0c978896f52491202e8451f8025"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a4b80e0c978896f52491202e8451f8025">bsreadln</a> (<a class="el" href="structtagbstring.html">bstring</a> b, struct bStream *s, char terminator)</td></tr>
<tr class="separator:a4b80e0c978896f52491202e8451f8025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d83d2449e4b13dbead049f93a1fce24"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a3d83d2449e4b13dbead049f93a1fce24">bsreadlns</a> (<a class="el" href="structtagbstring.html">bstring</a> r, struct bStream *s, const <a class="el" href="structtagbstring.html">bstring</a> term)</td></tr>
<tr class="separator:a3d83d2449e4b13dbead049f93a1fce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0dd2679b0d4d63086c9ec53dbba665"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#afd0dd2679b0d4d63086c9ec53dbba665">bsread</a> (<a class="el" href="structtagbstring.html">bstring</a> b, struct bStream *s, int n)</td></tr>
<tr class="separator:afd0dd2679b0d4d63086c9ec53dbba665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cebb47e8b79dc359f6bfae98a24363"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ad7cebb47e8b79dc359f6bfae98a24363">bsreadlna</a> (<a class="el" href="structtagbstring.html">bstring</a> b, struct bStream *s, char terminator)</td></tr>
<tr class="separator:ad7cebb47e8b79dc359f6bfae98a24363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dec273a7c9f2468c64356b07e24d213"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a7dec273a7c9f2468c64356b07e24d213">bsreadlnsa</a> (<a class="el" href="structtagbstring.html">bstring</a> r, struct bStream *s, const <a class="el" href="structtagbstring.html">bstring</a> term)</td></tr>
<tr class="separator:a7dec273a7c9f2468c64356b07e24d213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfbec9ee41315deab3302c66e2fc5ac"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a3cfbec9ee41315deab3302c66e2fc5ac">bsreada</a> (<a class="el" href="structtagbstring.html">bstring</a> b, struct bStream *s, int n)</td></tr>
<tr class="separator:a3cfbec9ee41315deab3302c66e2fc5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1269da6e6bb75f5a0fd4529cab74ef6b"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a1269da6e6bb75f5a0fd4529cab74ef6b">bsunread</a> (struct bStream *s, const <a class="el" href="structtagbstring.html">bstring</a> b)</td></tr>
<tr class="separator:a1269da6e6bb75f5a0fd4529cab74ef6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114e0702414bc301d1fffb3468a4566c"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a114e0702414bc301d1fffb3468a4566c">bspeek</a> (<a class="el" href="structtagbstring.html">bstring</a> r, const struct bStream *s)</td></tr>
<tr class="separator:a114e0702414bc301d1fffb3468a4566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710fdfb5235a8c244a9b05db5b2c802f"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a710fdfb5235a8c244a9b05db5b2c802f">bssplitscb</a> (struct bStream *s, const <a class="el" href="structtagbstring.html">bstring</a> splitStr, int(*cb)(void *parm, int ofs, const <a class="el" href="structtagbstring.html">bstring</a> entry), void *parm)</td></tr>
<tr class="separator:a710fdfb5235a8c244a9b05db5b2c802f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae866c8b53b094dac5bb52b03b5004a7d"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#ae866c8b53b094dac5bb52b03b5004a7d">bssplitstrcb</a> (struct bStream *s, const <a class="el" href="structtagbstring.html">bstring</a> splitStr, int(*cb)(void *parm, int ofs, const <a class="el" href="structtagbstring.html">bstring</a> entry), void *parm)</td></tr>
<tr class="separator:ae866c8b53b094dac5bb52b03b5004a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934dd8c5862bc9a1a152f24581352729"><td class="memItemLeft" align="right" valign="top">BSTR_PUBLIC int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bstrlib_8h.html#a934dd8c5862bc9a1a152f24581352729">bseof</a> (const struct bStream *s)</td></tr>
<tr class="separator:a934dd8c5862bc9a1a152f24581352729"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C implementaion of bstring functions. </p>
<p>This file is the header file for the core module for implementing the bstring functions. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a7d5203b5518eb6a79911185ad22fad42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bchar</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="bstrlib_8h.html#aa69796c26dc7f9831420c76f646a1e2c">bchare</a>((b), (p), '\0')</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the p'th character of the bstring b.</p>
<p>If the position p refers to a position that does not exist in the bstring or the bstring is NULL, then '\0' is returned. </p>

</div>
</div>
<a class="anchor" id="aa69796c26dc7f9831420c76f646a1e2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bchare</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((((unsigned)(p)) &lt; (<span class="keywordtype">unsigned</span>)<a class="code" href="bstrlib_8h.html#a462176ab60e31a2ead1b575b50b1124d">blength</a>(b)) \</div>
<div class="line">                ? ((b)-&gt;data[(p)]) \</div>
<div class="line">                : (e))</div>
</div><!-- fragment --><p>Returns the p'th character of the bstring b.</p>
<p>If the position p refers to a position that does not exist in the bstring or the bstring is NULL, then c is returned. </p>

</div>
</div>
<a class="anchor" id="a918e84c6f0ed26acc34882115e1bc896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bdata</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="bstrlib_8h.html#ae6becf2b45df687b618d745990b77846">bdataofs</a>(b, 0))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the char * data portion of the bstring b.</p>
<p>If b is NULL, NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a319493bef0d51c2d8f4214b30ca0846d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bdatae</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="bstrlib_8h.html#a7a17cc3f91a96c0c81f8c2032610a26f">bdataofse</a>(b, 0, e))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the char * data portion of the bstring b.</p>
<p>If b is NULL, err is returned. </p>

</div>
</div>
<a class="anchor" id="ae6becf2b45df687b618d745990b77846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bdataofs</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">o&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(<a class="el" href="bstrlib_8h.html#a7a17cc3f91a96c0c81f8c2032610a26f">bdataofse</a>((b),(o),(void *)0))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the char * data portion of the bstring b offset by ofs.</p>
<p>If b is NULL, NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a7a17cc3f91a96c0c81f8c2032610a26f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bdataofse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">o, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((b) == (<span class="keywordtype">void</span> *)0 || (b)-&gt;data == (<span class="keywordtype">void</span> *)0) \</div>
<div class="line">                ? (<span class="keywordtype">char</span> *)(e) \</div>
<div class="line">                : ((<span class="keywordtype">char</span> *)(b)-&gt;data) + (o))</div>
</div><!-- fragment --><p>Returns the char * data portion of the bstring b offset by ofs.</p>
<p>If b is NULL, err is returned. </p>

</div>
</div>
<a class="anchor" id="ae6f90b293b8f88607ae83c2feae7ae99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define biswriteprotected</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t</td><td>)</td>
          <td>&#160;&#160;&#160;((t).mlen &lt;= 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns 1 if the bstring is write protected, otherwise 0 is returned. </p>

</div>
</div>
<a class="anchor" id="a462176ab60e31a2ead1b575b50b1124d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define blength</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="bstrlib_8h.html#a1b3759bb27b16d4ed7f87d84eb36a64a">blengthe</a>((b), 0))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the bstring.</p>
<p>If the bstring is NULL, the length returned is 0. </p>

</div>
</div>
<a class="anchor" id="a1b3759bb27b16d4ed7f87d84eb36a64a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define blengthe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((b) == (<span class="keywordtype">void</span> *)0 || (b)-&gt;slen &lt; 0) \</div>
<div class="line">                ? (int)(e) \</div>
<div class="line">                : ((b)-&gt;slen))</div>
</div><!-- fragment --><p>Returns the length of the bstring.</p>
<p>If the bstring is NULL err is returned. </p>

</div>
</div>
<a class="anchor" id="a8fb8d7713b3e5c45ec688b0adcb012f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define blk2tbstr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {            \</div>
<div class="line">        (t).data = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)(s); \</div>
<div class="line">        (t).slen = l; \</div>
<div class="line">        (t).mlen = -1; \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aef11b11882ddf92fc7ab44b6d5f3a80d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bmid2tbstr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        const <a class="code" href="structtagbstring.html">bstring</a> bstrtmp_s =(b); \</div>
<div class="line">        if (bstrtmp_s &amp;&amp; bstrtmp_s-&gt;data &amp;&amp; bstrtmp_s-&gt;slen &gt;= 0) { \</div>
<div class="line">                int bstrtmp_left = (p); \</div>
<div class="line">                int bstrtmp_len  = (l); \</div>
<div class="line">                if (bstrtmp_left &lt; 0) { \</div>
<div class="line">                        bstrtmp_len += bstrtmp_left; \</div>
<div class="line">                        bstrtmp_left = 0; \</div>
<div class="line">                } \</div>
<div class="line">                if (bstrtmp_len &gt; bstrtmp_s-&gt;slen - bstrtmp_left) { \</div>
<div class="line">                        bstrtmp_len = bstrtmp_s-&gt;slen - bstrtmp_left; \</div>
<div class="line">                } \</div>
<div class="line">                if(bstrtmp_len &lt;= 0) { \</div>
<div class="line">                        (t).data =(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;&quot;</span>; \</div>
<div class="line">                        (t).slen = 0; \</div>
<div class="line">                } <span class="keywordflow">else</span> { \</div>
<div class="line">                        (t).data = bstrtmp_s-&gt;data + bstrtmp_left; \</div>
<div class="line">                        (t).slen = bstrtmp_len; \</div>
<div class="line">                } \</div>
<div class="line">        } <span class="keywordflow">else</span> { \</div>
<div class="line">                (t).data = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;&quot;</span>; \</div>
<div class="line">                (t).slen = 0; \</div>
<div class="line">        } \</div>
<div class="line">        (t).mlen = -__LINE__; \</div>
<div class="line">} <span class="keywordflow">while</span> (0);</div>
</div><!-- fragment --><p>Fill the tagbstring t with the substring from b, starting from position pos with a length len.</p>
<p>The segment is clamped by the boundaries of the bstring b. This action is purely reference oriented; no memory management is done. Note that the buffer is not appended with a '\0' character. Note that the t parameter to this macro may be accessed multiple times. Note that the contents of t will become undefined if the contents of b change or are destroyed.</p>
<p>The resulting struct tagbstring is permanently write protected. Attempts to write to this struct tagbstring in a write protected state from any bstrlib function will lead to BSTR_ERR being returned. Invoking the bwriteallow macro on this struct tagbstring will have no effect. </p>

</div>
</div>
<a class="anchor" id="ac3dc1cdd273f7d9edb89f6a4a49cb852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bsStaticBlkParms</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">q</td><td>)</td>
          <td>&#160;&#160;&#160;((void *)(&quot;&quot; q &quot;&quot;)), ((int)sizeof(q) -1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The bsStaticBlkParms macro emits a pair of comma seperated parameters corresponding to the block parameters for the block functions in Bstrlib (i.e., blk2bstr, bcatblk, blk2tbstr, bisstemeqblk, bisstemeqcaselessblk).</p>
<p>Note that this macro is only well defined for string literal arguments.</p>
<p>Examples:</p>
<div class="fragment"><div class="line"><a class="code" href="structtagbstring.html">bstring</a> b = <a class="code" href="bstrlib_8h.html#a74fe48dc5f5d956651f8271e77714df5">blk2bstr</a>(<a class="code" href="bstrlib_8h.html#ac3dc1cdd273f7d9edb89f6a4a49cb852">bsStaticBlkParms</a>(<span class="stringliteral">&quot;Fast init.&quot;</span>));</div>
<div class="line"><a class="code" href="bstrlib_8h.html#a78e247b5c21799751f25f3edaaf3842e">bcatblk</a>(b, <a class="code" href="bstrlib_8h.html#ac3dc1cdd273f7d9edb89f6a4a49cb852">bsStaticBlkParms</a>(<span class="stringliteral">&quot;No frills fast concatenation.&quot;</span>));</div>
</div><!-- fragment --><p>These are faster than using <a class="el" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr()</a> and <a class="el" href="bstrlib_8h.html#aab64bb6f143468a52577081ee438edbc">bcatcstr()</a> respectively because the length of the inline string is known as a compile time constant. Also note that seperate struct tagbstring declarations for </p>

</div>
</div>
<a class="anchor" id="aab243648d3d35096c9a9fc8d573d6827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bstrchr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="bstrlib_8h.html#a26209ea604a59389a452ad1c02f24c40">bstrchrp</a>((b), (c), 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the character c in the bstring b forwards from the start of the bstring.</p>
<p>Returns the position of the found character or BSTR_ERR if it is not found. </p>

</div>
</div>
<a class="anchor" id="a56057bf0b9c17ba18bc47135ed5eb2c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bstrrchr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="bstrlib_8h.html#a7f3e67d89be749a1d2e5ffede2d6f29c">bstrrchrp</a>((b), (c), <a class="el" href="bstrlib_8h.html#a462176ab60e31a2ead1b575b50b1124d">blength</a>(b) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the character c in the bstring b backwards from the end of the bstring.</p>
<p>Returns the position of the found character or BSTR_ERR if it is not found. </p>

</div>
</div>
<a class="anchor" id="aa6f4ba9c4ffa4800e7214ed13d1ae81c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btfromblk</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;blk2tbstr(t, s, l)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill in the tagbstring t with the data buffer s with length len.</p>
<p>This action is purely reference oriented; no memory management is done. The data member of t is just assigned s, and slen is assigned len. Note that the buffer is not appended with a '\0' character. The s and len parameters are accessed exactly once each in this macro.</p>
<p>The resulting struct tagbstring is initially write protected. Attempts to write to this struct tagbstring in a write protected state from any bstrlib function will lead to BSTR_ERR being returned. Invoke the bwriteallow on this struct tagbstring to make it writeable (though this requires that s be obtained from a function compatible with malloc.) </p>

</div>
</div>
<a class="anchor" id="a168c04182fd97834fbe508fa8c186991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btfromblkltrimws</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        int bstrtmp_idx = 0, bstrtmp_len =(l); \</div>
<div class="line">        unsigned <span class="keywordtype">char</span> *bstrtmp_s = (s); \</div>
<div class="line">        if (bstrtmp_s &amp;&amp; bstrtmp_len &gt;= 0) { \</div>
<div class="line">                for (; bstrtmp_idx &lt; bstrtmp_len; bstrtmp_idx++) {                   \</div>
<div class="line">                        if (!isspace(bstrtmp_s[bstrtmp_idx])) { \</div>
<div class="line">                                break; \</div>
<div class="line">                        } \</div>
<div class="line">                } \</div>
<div class="line">        } \</div>
<div class="line">        (t).data = bstrtmp_s + bstrtmp_idx; \</div>
<div class="line">        (t).slen = bstrtmp_len - bstrtmp_idx; \</div>
<div class="line">        (t).mlen = -__LINE__; \</div>
<div class="line">} <span class="keywordflow">while</span> (0);</div>
</div><!-- fragment --><p>Fill in the tagbstring t with the data buffer s with length len after it has been left trimmed.</p>
<p>This action is purely reference oriented; no memory management is done. The data member of t is just assigned to a pointer inside the buffer s. Note that the buffer is not appended with a '\0' character. The s and len parameters are accessed exactly once each in this macro.</p>
<p>The resulting struct tagbstring is permanently write protected. Attempts to write to this struct tagbstring from any bstrlib function will lead to BSTR_ERR being returned. Invoking the bwriteallow macro onto this struct tagbstring has no effect. </p>

</div>
</div>
<a class="anchor" id="a9590d06aa5bc93a8031d5bbaccf75373"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btfromblkrtrimws</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        int bstrtmp_len = (l) - 1; \</div>
<div class="line">        unsigned <span class="keywordtype">char</span> *bstrtmp_s = (s); \</div>
<div class="line">        if (bstrtmp_s &amp;&amp; bstrtmp_len &gt;= 0) { \</div>
<div class="line">                for (; bstrtmp_len &gt;= 0; bstrtmp_len--) { \</div>
<div class="line">                        if (!isspace(bstrtmp_s[bstrtmp_len])) { \</div>
<div class="line">                                break; \</div>
<div class="line">                        } \</div>
<div class="line">                } \</div>
<div class="line">        } \</div>
<div class="line">        (t).data = bstrtmp_s; \</div>
<div class="line">        (t).slen = bstrtmp_len + 1; \</div>
<div class="line">        (t).mlen = -__LINE__; \</div>
<div class="line">} <span class="keywordflow">while</span> (0);</div>
</div><!-- fragment --><p>Fill in the tagbstring t with the data buffer s with length len after it has been right trimmed.</p>
<p>This action is purely reference oriented; no memory management is done. The data member of t is just assigned to a pointer inside the buffer s. Note that the buffer is not appended with a '\0' character. The s and len parameters are accessed exactly once each in this macro.</p>
<p>The resulting struct tagbstring is permanently write protected. Attempts to write to this struct tagbstring from any bstrlib function will lead to BSTR_ERR being returned. Invoking the bwriteallow macro onto this struct tagbstring has no effect. </p>

</div>
</div>
<a class="anchor" id="afa5e9e949494d2c5d3f8749b48685e5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btfromblktrimws</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        int bstrtmp_idx = 0, bstrtmp_len = (l) - 1; \</div>
<div class="line">        unsigned <span class="keywordtype">char</span> *bstrtmp_s = (s); \</div>
<div class="line">        if (bstrtmp_s &amp;&amp; bstrtmp_len &gt;= 0) { \</div>
<div class="line">                for (; bstrtmp_idx &lt;= bstrtmp_len; bstrtmp_idx++) { \</div>
<div class="line">                        if(!isspace(bstrtmp_s[bstrtmp_idx])) { \</div>
<div class="line">                                break; \</div>
<div class="line">                        } \</div>
<div class="line">                } \</div>
<div class="line">                for (; bstrtmp_len &gt;= bstrtmp_idx; bstrtmp_len--) { \</div>
<div class="line">                        if (!isspace(bstrtmp_s[bstrtmp_len])) { \</div>
<div class="line">                                break; \</div>
<div class="line">                        } \</div>
<div class="line">                } \</div>
<div class="line">        } \</div>
<div class="line">        (t).data = bstrtmp_s + bstrtmp_idx; \</div>
<div class="line">        (t).slen = bstrtmp_len + 1 - bstrtmp_idx; \</div>
<div class="line">        (t).mlen = -__LINE__; \</div>
<div class="line">} <span class="keywordflow">while</span> (0);</div>
</div><!-- fragment --><p>Fill in the tagbstring t with the data buffer s with length len after it has been left and right trimmed.</p>
<p>This action is purely reference oriented; no memory management is done. The data member of t is just assigned to a pointer inside the buffer s. Note that the buffer is not appended with a '\0' character. The s and len parameters are accessed exactly once each in this macro.</p>
<p>The resulting struct tagbstring is permanently write protected. Attempts to write to this struct tagbstring from any bstrlib function will lead to BSTR_ERR being returned. Invoking the bwriteallow macro onto this struct tagbstring has no effect. </p>

</div>
</div>
<a class="anchor" id="a52bfb9d7cacb9f51e42066e2fe3e5a99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btfromcstr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        (t).data = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)(s); \</div>
<div class="line">        (t).slen = ((t).data) \</div>
<div class="line">                ? ((<span class="keywordtype">int</span>)(strlen)((<span class="keywordtype">char</span> *)(t).data)) \</div>
<div class="line">                : 0; \</div>
<div class="line">        (t).mlen = -1; \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Fill in the tagbstring t with the '\0' terminated char buffer s.</p>
<p>This action is purely reference oriented; no memory management is done. The data member is just assigned s, and slen is assigned the strlen of s. The s parameter is accessed exactly once in this macro.</p>
<p>The resulting struct tagbstring is initially write protected. Attempts to write to this struct tagbstring in a write protected state from any bstrlib function will lead to BSTR_ERR being returned. Invoke the bwriteallow on this struct tagbstring to make it writeable (though this requires that s be obtained from a function compatible with malloc.) </p>

</div>
</div>
<a class="anchor" id="afa1682c36488d56476284d722c0fabab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bvformata</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lastarg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { <a class="code" href="structtagbstring.html">\</a></div>
<div class="line"><a class="code" href="structtagbstring.html">	bstring</a> bstrtmp_b =(b); \</div>
<div class="line">        const <span class="keywordtype">char</span> *bstrtmp_fmt = (fmt); \</div>
<div class="line">        int bstrtmp_r = BSTR_ERR, bstrtmp_sz = 16; \</div>
<div class="line">        for (;;) { \</div>
<div class="line">                va_list bstrtmp_arglist; \</div>
<div class="line">                va_start(bstrtmp_arglist, lastarg); \</div>
<div class="line">                bstrtmp_r = <a class="code" href="bstrlib_8h.html#a6435bf68d7a8ea9a1c73c4b4c3358005">bvcformata</a>(bstrtmp_b, bstrtmp_sz, bstrtmp_fmt, \</div>
<div class="line">                                       bstrtmp_arglist); \</div>
<div class="line">                va_end(bstrtmp_arglist); \</div>
<div class="line">                if(bstrtmp_r &gt;= 0) { \</div>
<div class="line">                        <span class="comment">/* Everything went ok */</span> \</div>
<div class="line">                        bstrtmp_r = BSTR_OK; \</div>
<div class="line">                        break; \</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(-bstrtmp_r &lt;= bstrtmp_sz) { \</div>
<div class="line">                        <span class="comment">/* A real error? */</span> \</div>
<div class="line">                        bstrtmp_r = BSTR_ERR; \</div>
<div class="line">                        break; \</div>
<div class="line">                } \</div>
<div class="line">                <span class="comment">/* Doubled or target size */</span> \</div>
<div class="line">                bstrtmp_sz = -bstrtmp_r; \</div>
<div class="line">        } \</div>
<div class="line">        ret = bstrtmp_r; \</div>
<div class="line">} <span class="keywordflow">while</span> (0);</div>
</div><!-- fragment --><p>Append the bstring b with printf like formatting with the format control string, and the arguments taken from the list of arguments after lastarg passed to the containing function.</p>
<p>If the containing function does not have extra parameters or lastarg is not the last named parameter before the extra parameters then the results are undefined. If successful, the results are appended to b and BSTR_OK is assigned to ret. Otherwise BSTR_ERR is assigned to ret.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> dbgerror (FILE *fp, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> ret;</div>
<div class="line">    <a class="code" href="structtagbstring.html">bstring</a> b;</div>
<div class="line">    <a class="code" href="bstrlib_8h.html#afa1682c36488d56476284d722c0fabab">bvformata</a>(ret, b = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a> (<span class="stringliteral">&quot;DBG: &quot;</span>), fmt, fmt);</div>
<div class="line">    <span class="keywordflow">if</span> (BSTR_OK == ret) {</div>
<div class="line">        fputs ((<span class="keywordtype">char</span> *) <a class="code" href="bstrlib_8h.html#a918e84c6f0ed26acc34882115e1bc896">bdata</a> (b), fp);</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="bstrlib_8h.html#a54df7a3d5fc9b10de67c4ea4adaec8fa">bdestroy</a> (b);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a20e39e69cf2035b12da65078eb1b9817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bwriteallow</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        if ((t).mlen == -1) { \</div>
<div class="line">                (t).mlen = (t).slen + ((t).slen == 0); \</div>
<div class="line">        } \</div>
<div class="line">} <span class="keywordflow">while</span> (0);</div>
</div><!-- fragment --><p>Allow bstring to be written to via the bstrlib API.</p>
<p>Note that such an action makes the bstring both writable and destroyable. If the bstring is not legitimately writable (as is the case for struct tagbstrings initialized with a bsStatic value), the results of this are undefined.</p>
<p>Note that invoking the bwriteallow macro may increase the number of reallocs by one more than necessary for every call to bwriteallow interleaved with any bstring API which writes to this bstring. </p>

</div>
</div>
<a class="anchor" id="a3b9759ad92b645976d14692362f2ed10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bwriteprotect</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">        if ((t).mlen &gt;=  0) { \</div>
<div class="line">                (t).mlen = -1; \</div>
<div class="line">        } \</div>
<div class="line">} <span class="keywordflow">while</span> (0);</div>
</div><!-- fragment --><p>Disallow bstring from being written to via the bstrlib API.</p>
<p>Attempts to write to the resulting tagbstring from any bstrlib function will lead to BSTR_ERR being returned.</p>
<p>Note: bstrings which are write protected cannot be destroyed via bdestroy. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af67ff6de70096458f580242a5c40cdd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int balloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increase the allocated memory backing the data buffer for the bstring b to a length of at least length.</p>
<p>If the memory backing the bstring b is already large enough, not action is performed. This has no effect on the bstring b that is visible to the bstring API. Usually this function will only be used when a minimum buffer size is required coupled with a direct access to the -&gt;data member of the bstring structure.</p>
<p>Be warned that like any other bstring function, the bstring must be well defined upon entry to this function, i.e., doing something like:</p>
<div class="fragment"><div class="line">b-&gt;slen *= 2;</div>
<div class="line"><a class="code" href="bstrlib_8h.html#af67ff6de70096458f580242a5c40cdd6">balloc</a>(b, b-&gt;slen);</div>
</div><!-- fragment --><p>is invalid, and should be implemented as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> t;</div>
<div class="line"><span class="keywordflow">if</span> (BSTR_OK == <a class="code" href="bstrlib_8h.html#af67ff6de70096458f580242a5c40cdd6">balloc</a> (b, t = (b-&gt;slen * 2))) {</div>
<div class="line">    b-&gt;slen = t;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function will return with BSTR_ERR if b is not detected as a valid bstring or length is not greater than 0, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="a25f1998603f26df1ee66ebebc370d403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int ballocmin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the amount of memory backing the bstring b to at least length.</p>
<p>This operation will never truncate the bstring data including the extra terminating '\0' and thus will not decrease the length to less than b-&gt;slen + 1. Note that repeated use of this function may cause performance problems (realloc may be called on the bstring more than the O(log(INT_MAX)) times). This function will return with BSTR_ERR if b is not detected as a valid bstring or length is not greater than 0, otherwise BSTR_OK is returned.</p>
<p>So for example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (BSTR_OK == <a class="code" href="bstrlib_8h.html#a25f1998603f26df1ee66ebebc370d403">ballocmin</a> (b, 64)) {</div>
<div class="line">    b-&gt;data[63] = <span class="charliteral">&#39;x&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The idea is that this will set the 64th character of b to 'x' if it is at least 64 characters long otherwise do nothing. And we know this is well defined so long as the ballocmin call was successfully, since it will ensure that b has been allocated with at least 64 characters. </p>

</div>
</div>
<a class="anchor" id="a03204f69b283e7b069fa2655b959b7c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bassign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwrite the bstring a with the contents of bstring b.</p>
<p>Note that the bstring a must be a well defined and writable bstring. If an error occurs BSTR_ERR is returned and a is not overwritten. </p>

</div>
</div>
<a class="anchor" id="ad5d4b984c1780a38cd929c7265af1ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bassignblk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwrite the bstring a with the middle of contents of bstring b starting from position left and running for a length len.</p>
<p>left and len are clamped to the ends of b as with the function bmidstr. Note that the bstring a must be a well defined and writable bstring. If an error occurs BSTR_ERR is returned and a is not overwritten. </p>

</div>
</div>
<a class="anchor" id="a794183c3f291f4a990028353ce721a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bassigncstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwrite the string a with the contents of char * string str.</p>
<p>Note that the bstring a must be a well defined and writable bstring. If an error occurs BSTR_ERR is returned and a may be partially overwritten. </p>

</div>
</div>
<a class="anchor" id="a740190ec821c74f2c337332727c19183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bassignformat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After the first parameter, it takes the same parameters as printf(), but rather than outputting results to stdio, it outputs the results to the bstring parameter b.</p>
<p>Note that if there is an early generation of a '\0' character, the bstring will be truncated to this end point.</p>
<p>Note that s format tokens correspond to '\0' terminated char * buffers, not bstrings. To print a bstring, first dereference data element of the the bstring:</p>
<p>b1-&gt;data needs to be '\0' terminated, so tagbstrings generated by blk2tbstr() might not be suitable.</p>
<div class="fragment"><div class="line"><a class="code" href="bstrlib_8h.html#a740190ec821c74f2c337332727c19183">bassignformat</a> (b0 = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a> (<span class="stringliteral">&quot;Hello&quot;</span>), <span class="stringliteral">&quot;, %s&quot;</span>, b1-&gt;data);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8281820fe0c167b0433408e75f140289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bassigngets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bNgetc&#160;</td>
          <td class="paramname"><em>getcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from a stream and concatenate to a bstring.</p>
<p>Behaves like bgets, except that it assigns the results to the bstring b. The value 1 is returned if no characters are read before a negative result is returned from getcPtr. Otherwise BSTR_ERR is returned on error, and 0 is returned in other normal cases. </p>

</div>
</div>
<a class="anchor" id="aac41f39c29a40d34ea5342b027719a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bassignmidstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwrite the bstring a with the middle of contents of bstring b starting from position left and running for a length len.</p>
<p>left and len are clamped to the ends of b as with the function bmidstr. Note that the bstring a must be a well defined and writable bstring. If an error occurs BSTR_ERR is returned and a is not overwritten. </p>

</div>
</div>
<a class="anchor" id="a78e247b5c21799751f25f3edaaf3842e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bcatblk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate a fixed length buffer (s, len) to the end of bstring b.</p>
<p>The value BSTR_OK is returned if the operation is successful, otherwise BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="aab64bb6f143468a52577081ee438edbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bcatcstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate the char * string s to the end of bstring b.</p>
<p>The value BSTR_OK is returned if the operation is successful, otherwise BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="a344d26e5127bb1022debe55a53b20f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bconcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate the bstring b1 to the end of bstring b0.</p>
<p>The value BSTR_OK is returned if the operation is successful, otherwise BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="a659957485042fd8954abdcab51f30479"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bconchar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate the character c to the end of bstring b.</p>
<p>The value BSTR_OK is returned if the operation is successful, otherwise BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="a3f493957027d9cb58a87dbe611975564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bcstrfree </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a C-string generated by <a class="el" href="bstrlib_8h.html#a8333d17de053dc35dc306ff347c4a167">bstr2cstr()</a>.</p>
<p>This is normally unnecessary since it just wraps a call to free(), however, if malloc() and free() have been redefined as a macros within the bstrlib module (via macros in the memdbg.h backdoor) with some difference in behaviour from the std library functions, then this allows a correct way of freeing the memory that allows higher level code to be independent from these macro redefinitions. </p>

</div>
</div>
<a class="anchor" id="a4345c14c3bd03532e3eab3cad2397f0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bdelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes characters from pos to pos+len-1 and shifts the tail of the bstring starting from pos+len to pos.</p>
<p>len must be positive for this call to have any effect. The section of the bstring described by (pos, len) is clamped to boundaries of the bstring b. The value BSTR_OK is returned if the operation is successful, otherwise BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="a54df7a3d5fc9b10de67c4ea4adaec8fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bdestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate the bstring passed.</p>
<p>Passing NULL in as a parameter will have no effect. Note that both the header and the data portion of the bstring will be freed. No other bstring function which modifies one of its parameters will free or reallocate the header. Because of this, in general, bdestroy cannot be called on any declared struct tagbstring even if it is not write protected. A bstring which is write protected cannot be destroyed via the bdestroy call. Any attempt to do so will result in no action taken, and BSTR_ERR will be returned. </p>

</div>
</div>
<a class="anchor" id="a92d6e07b000086ff0a8e2b4921305a74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bfindreplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace all occurrences of the find substring with a replace bstring after a given position in the bstring b.</p>
<p>The find bstring must have a length &gt; 0 otherwise BSTR_ERR is returned. This function does not perform recursive per character replacement; that is to say successive searches resume at the position after the last replace.</p>
<p>So for example:</p>
<div class="fragment"><div class="line"><a class="code" href="bstrlib_8h.html#a92d6e07b000086ff0a8e2b4921305a74">bfindreplace</a>(a0 = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a>(<span class="stringliteral">&quot;aabaAb&quot;</span>), a1 = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a>(<span class="stringliteral">&quot;a&quot;</span>),</div>
<div class="line">             a2 = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a>(<span class="stringliteral">&quot;aa&quot;</span>), 0);</div>
</div><!-- fragment --><p>Should result in changing a0 to "aaaabaaAb".</p>
<p>This function performs exactly (b-&gt;slen - position) bstring comparisons, and data movement is bounded above by character volume equivalent to size of the output bstring. </p>

</div>
</div>
<a class="anchor" id="ab0cdcf157780778de69f0510e8292345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bfindreplacecaseless </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace all occurrences of the find substring, ignoring case, with a replace bstring after a given position in the bstring b.</p>
<p>The find bstring must have a length &gt; 0 otherwise BSTR_ERR is returned. This function does not perform recursive per character replacement; that is to say successive searches resume at the position after the last replace.</p>
<p>So for example:</p>
<div class="fragment"><div class="line"><a class="code" href="bstrlib_8h.html#ab0cdcf157780778de69f0510e8292345">bfindreplacecaseless</a>(a0 = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a>(<span class="stringliteral">&quot;AAbaAb&quot;</span>), a1 = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a>(<span class="stringliteral">&quot;a&quot;</span>),</div>
<div class="line">a2 = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a>(<span class="stringliteral">&quot;aa&quot;</span>), 0);</div>
</div><!-- fragment --><p>Should result in changing a0 to "aaaabaaaab".</p>
<p>This function performs exactly (b-&gt;slen - position) bstring comparisons, and data movement is bounded above by character volume equivalent to size of the output bstring. </p>

</div>
</div>
<a class="anchor" id="aed8673536cc6151d8486d79f619b9257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a> bformat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes the same parameters as printf(), but rather than outputting results to stdio, it forms a bstring which contains what would have been output.</p>
<p>Note that if there is an early generation of a '\0' character, the bstring will be truncated to this end point.</p>
<p>Note that s format tokens correspond to '\0' terminated char * buffers, not bstrings. To print a bstring, first dereference data element of the the bstring:</p>
<p>b1-&gt;data needs to be '\0' terminated, so tagbstrings generated by blk2tbstr() might not be suitable.</p>
<div class="fragment"><div class="line">b0 = <a class="code" href="bstrlib_8h.html#aed8673536cc6151d8486d79f619b9257">bformat</a> (<span class="stringliteral">&quot;Hello, %s&quot;</span>, b1-&gt;data);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5b1ba2c8d1deae8c2499114c95b2b745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bformata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In addition to the initial output buffer b, bformata takes the same parameters as printf (), but rather than outputting results to stdio, it appends the results to the initial bstring parameter.</p>
<p>Note that if there is an early generation of a '\0' character, the bstring will be truncated to this end point.</p>
<p>Note that s format tokens correspond to '\0' terminated char * buffers, not bstrings. To print a bstring, first dereference data element of the the bstring:</p>
<p>b1-&gt;data needs to be '\0' terminated, so tagbstrings generated by blk2tbstr() might not be suitable.</p>
<div class="fragment"><div class="line"><a class="code" href="bstrlib_8h.html#a5b1ba2c8d1deae8c2499114c95b2b745">bformata</a> (b0 = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a> (<span class="stringliteral">&quot;Hello&quot;</span>), <span class="stringliteral">&quot;, %s&quot;</span>, b1-&gt;data);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a18bcf0b649f36e9023a20cf42d5eb375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a> bfromcstr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a standard C library style '\0' terminated char buffer and generate a bstring with the same contents as the char buffer.</p>
<p>If an error occurs #NULL is returned.</p>
<div class="fragment"><div class="line"><a class="code" href="structtagbstring.html">bstring</a> b = <a class="code" href="bstrlib_8h.html#a18bcf0b649f36e9023a20cf42d5eb375">bfromcstr</a>(<span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!b) {</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Out of memory&quot;</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    puts((<span class="keywordtype">char</span> *)b-&gt;data);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a55ccc3632116698a0dd443dd1e4b0d5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a> bfromcstralloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bstring which contains the contents of the '\0' terminated char *buffer str.</p>
<p>The memory buffer backing the bstring is at least mlen characters in length. If an error occurs NULL is returned.</p>
<div class="fragment"><div class="line"><a class="code" href="structtagbstring.html">bstring</a> b = <a class="code" href="bstrlib_8h.html#a55ccc3632116698a0dd443dd1e4b0d5d">bfromcstralloc</a>(64, someCstr);</div>
<div class="line"><span class="keywordflow">if</span>(b) {</div>
<div class="line">    b-&gt;data[63] = <span class="charliteral">&#39;x&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The idea is that this will set the 64th character of b to 'x' if it is at least 64 characters long otherwise do nothing. And we know this is well defined so long as b was successfully created, since it will have been allocated with at least 64 characters. </p>

</div>
</div>
<a class="anchor" id="a9d6e5799ae68950782222b26bef14fd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a> bgets </td>
          <td>(</td>
          <td class="paramtype">bNgetc&#160;</td>
          <td class="paramname"><em>getcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a bstring from a stream.</p>
<p>As many bytes as is necessary are read until the terminator is consumed or no more characters are available from the stream. If read from the stream, the terminator character will be appended to the end of the returned bstring. The getcPtr function must have the same semantics as the fgetc C library function (i.e., returning an integer whose value is negative when there are no more characters available, otherwise the value of the next available unsigned character from the stream.) The intention is that parm would contain the stream data context/state required (similar to the role of the FILE* I/O stream parameter of fgets.) If no characters are read, or there is some other detectable error, NULL is returned.</p>
<p>bgets will never call the getcPtr function more often than necessary to construct its output (including a single call, if required, to determine that the stream contains no more characters.)</p>
<p>Abstracting the character stream function and terminator character allows for different stream devices and string formats other than '<br/>
' terminated lines in a file if desired (consider \032 terminated email messages, in a UNIX mailbox for example.)</p>
<p>For files, this function can be used analogously as fgets as follows:</p>
<div class="fragment"><div class="line">fp = fopen( ... );</div>
<div class="line"><span class="keywordflow">if</span> (fp) b = <a class="code" href="bstrlib_8h.html#a9d6e5799ae68950782222b26bef14fd1">bgets</a>((bNgetc) fgetc, fp, <span class="charliteral">&#39;\n&#39;</span>);</div>
</div><!-- fragment --><p>(Note that only one terminator character can be used, and that '\0' is not assumed to terminate the stream in addition to the terminator character. This is consistent with the semantics of fgets.) </p>

</div>
</div>
<a class="anchor" id="a8f688c14b7a896537f7ade1b825fd988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bgetsa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bNgetc&#160;</td>
          <td class="paramname"><em>getcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from a stream and concatenate to a bstring.</p>
<p>Behaves like bgets, except that it appends it results to the bstring b. The value 1 is returned if no characters are read before a negative result is returned from getcPtr. Otherwise BSTR_ERR is returned on error, and 0 is returned in other normal cases. </p>

</div>
</div>
<a class="anchor" id="ad18ed003f2c77ae2fed30cb7cd3ca932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int binchr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the first position in b0 starting from pos or after, in which one of the characters in b1 is found.</p>
<p>This function has an execution time of O(b0-&gt;slen + b1-&gt;slen). If such a position does not exist in b0, then BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="a647b29e54d24d416aef212a06df93d84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int binchrr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the last position in b0 no greater than pos, in which one of the characters in b1 is found.</p>
<p>This function has an execution time of O(b0-&gt;slen + b1-&gt;slen). If such a position does not exist in b0, then BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="af4d94781f02d5a220b3f1da9225916ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int binsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts the bstring s2 into s1 at position pos.</p>
<p>If the position pos is past the end of s1, then the character "fill" is appended as necessary to make up the gap between the end of s1 and pos. The value BSTR_OK is returned if the operation is successful, otherwise BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="ab0e719f952bf0b19e210a46f4df0ff95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int binsertch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts the character fill repeatedly into s1 at position pos for a length len.</p>
<p>If the position pos is past the end of s1, then the character "fill" is appended as necessary to make up the gap between the end of s1 and the position pos + len (exclusive). The value BSTR_OK is returned if the operation is successful, otherwise BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="af8e75dc6bc508a9f35e5b0864b28fecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int binstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the bstring s2 in s1 starting at position pos and looking in a forward (increasing) direction.</p>
<p>If it is found then it returns with the first position after pos where it is found, otherwise it returns BSTR_ERR. The algorithm used is brute force; O(m*n). </p>

</div>
</div>
<a class="anchor" id="a5c741078241e60bfe2caaf3427a97d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int binstrcaseless </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the bstring s2 in s1 starting at position pos and looking in a forward (increasing) direction but without regard to case.</p>
<p>If it is found then it returns with the first position after pos where it is found, otherwise it returns BSTR_ERR. The algorithm used is brute force; O(m*n). </p>

</div>
</div>
<a class="anchor" id="a2980cb23f483902859897017d80d599b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int binstrr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the bstring s2 in s1 starting at position pos and looking in a backward (decreasing) direction.</p>
<p>If it is found then it returns with the first position after pos where it is found, otherwise return BSTR_ERR. Note that the current position at pos is tested as well &ndash; so to be disjoint from a previous forward search it is recommended that the position be backed up (decremented) by one position. The algorithm used is brute force; O(m*n). </p>

</div>
</div>
<a class="anchor" id="a0c09ddbed79e6be9b54a0df8a143a327"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int binstrrcaseless </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the bstring s2 in s1 starting at position pos and looking in a backward (decreasing) direction but without regard to case.</p>
<p>If it is found then it returns with the first position after pos where it is found, otherwise return BSTR_ERR. Note that the current position at pos is tested as well &ndash; so to be disjoint from a previous forward search it is recommended that the position be backed up (decremented) by one position. The algorithm used is brute force; O(m*n). </p>

</div>
</div>
<a class="anchor" id="a97b4e2aeaaeec2848dac58a98be96fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int biseq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare the bstring b0 and b1 for equality.</p>
<p>If the bstrings differ, 0 is returned, if the bstrings are the same, 1 is returned, if there is an error, -1 is returned. If the length of the bstrings are different, this function has O(1) complexity. Contained '\0' characters are not treated as a termination character.</p>
<p>Note that the semantics of biseq are not completely compatible with bstrcmp because of its different treatment of the '\0' character. </p>

</div>
</div>
<a class="anchor" id="ac8c60e43cf81fd05d7233806b898aa1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int biseqcaseless </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two bstrings for equality without differentiating between case.</p>
<p>If the bstrings differ other than in case, 0 is returned, if the bstrings are the same, 1 is returned, if there is an error, -1 is returned. If the length of the bstrings are different, this function is O(1). '\0' termination characters are not treated in any special way. </p>

</div>
</div>
<a class="anchor" id="a63fdf5fc281ccc8f5f78ceb581ab95fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int biseqcstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare the bstring b and char * string s.</p>
<p>The C string s must be '\0' terminated at exactly the length of the bstring b, and the contents between the two must be identical with the bstring b with no '\0' characters for the two contents to be considered equal. This is equivalent to the condition that their current contents will be always be equal when comparing them in the same format after converting one or the other. If they are equal 1 is returned, if they are unequal 0 is returned and if there is a detectable error BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="aadaaf55f6c0f00b5b2a3aef06f21eb97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int biseqcstrcaseless </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare the bstring b and char * string s.</p>
<p>The C string s must be '\0' terminated at exactly the length of the bstring b, and the contents between the two must be identical except for case with the bstring b with no '\0' characters for the two contents to be considered equal. This is equivalent to the condition that their current contents will be always be equal ignoring case when comparing them in the same format after converting one or the other. If they are equal, except for case, 1 is returned, if they are unequal regardless of case 0 is returned and if there is a detectable error BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="a04a399414ee20f508215c38c7df5a193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bisstemeqblk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare beginning of bstring b0 with a block of memory of length len for equality.</p>
<p>If the beginning of b0 differs from the memory block (or if b0 is too short), 0 is returned, if the bstrings are the same, 1 is returned, if there is an error, -1 is returned. </p>

</div>
</div>
<a class="anchor" id="ace6abf7ef0b3e5d8d0d89f5e23979bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bisstemeqcaselessblk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare beginning of bstring b0 with a block of memory of length len without differentiating between case for equality.</p>
<p>If the beginning of b0 differs from the memory block other than in case (or if b0 is too short), 0 is returned, if the bstrings are the same, 1 is returned, if there is an error, -1 is returned. </p>

</div>
</div>
<a class="anchor" id="ac9503d1b05b9a8a06cb80eeb68425be8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a> bjoin </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbstrList.html">bstrList</a> *&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Join the entries of a <a class="el" href="structbstrList.html">bstrList</a> into one bstring by sequentially concatenating them with the sep bstring in between.</p>
<p>If sep is NULL, it is treated as if it were the empty bstring. Note that:</p>
<div class="fragment"><div class="line"><a class="code" href="bstrlib_8h.html#ac9503d1b05b9a8a06cb80eeb68425be8">bjoin</a> (l = <a class="code" href="bstrlib_8h.html#a09dfbbd9ceb54609674f93efb2ef4270">bsplit</a> (b, s-&gt;data[0]), s);</div>
</div><!-- fragment --><p>should result in a copy of b, if s-&gt;slen is 1. If there is an error NULL is returned, otherwise a bstring with the correct result is returned. See <a class="el" href="bstrlib_8h.html#ac8256fd68b32e1f855d8663c2ba9673f">bstrListCreate()</a> above for structure of struct <a class="el" href="structbstrList.html">bstrList</a>. </p>

</div>
</div>
<a class="anchor" id="a74fe48dc5f5d956651f8271e77714df5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a> blk2bstr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bstring whose contents are described by the contiguous buffer pointing to by blk with a length of len bytes.</p>
<p>Note that this function creates a copy of the data in blk, rather than simply referencing it. Compare with the blk2tbstr macro. If an error occurs NULL is returned. </p>

</div>
</div>
<a class="anchor" id="ab5815a4475417b84fde7ee94316f7eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bltrimws </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete whitespace contiguous from the left end of the bstring.</p>
<p>This function will return with BSTR_ERR if b is NULL or of length 0, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="a5134b739729cb0a2fc2111e53a1d727a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a> bmidstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bstring which is the substring of b starting from position left and running for a length len (clamped by the end of the bstring b).</p>
<p>If there was no error, the value of this constructed bstring is returned otherwise NULL is returned. </p>

</div>
</div>
<a class="anchor" id="ae2ee9be8c6a2145f819ecf2a31f0bff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bninchr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the first position in b0 starting from pos or after, in which none of the characters in b1 is found and return it.</p>
<p>This function has an execution time of O(b0-&gt;slen + b1-&gt;slen). If such a position does not exist in b0, then BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="a5d1c06a048e8ef6710e7e4142f8ab9ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bninchrr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the last position in b0 no greater than pos, in which none of the characters in b1 is found and return it.</p>
<p>This function has an execution time of O(b0-&gt;slen + b1-&gt;slen). If such a position does not exist in b0, then BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="a0a6ca96a5357fe5723de6bb53c039976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bpattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replicate the starting bstring, b, end to end repeatedly until it surpasses len characters, then chop the result to exactly len characters.</p>
<p>This function operates in-place. This function will return with BSTR_ERR if b is NULL or of length 0, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="a28d1bab886542a8abc1d441e2d2b669c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a> bread </td>
          <td>(</td>
          <td class="paramtype">bNread&#160;</td>
          <td class="paramname"><em>readPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an entire stream into a bstring, verbatum.</p>
<p>The readPtr function pointer is compatible with fread sematics, except that it need not obtain the stream data from a file. The intention is that parm would contain the stream data context/state required (similar to the role of the FILE* I/O stream parameter of fread.)</p>
<p>Abstracting the block read function allows for block devices other than file streams to be read if desired. Note that there is an ANSI compatibility issue if "fread" is used directly; see the ANSI issues section below. </p>

</div>
</div>
<a class="anchor" id="abd682527c9a84dfeb91bdbf4e8856ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int breada </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bNread&#160;</td>
          <td class="paramname"><em>readPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an entire stream and append it to a bstring, verbatim.</p>
<p>Behaves like bread, except that it appends it results to the bstring b. BSTR_ERR is returned on error, otherwise 0 is returned. </p>

</div>
</div>
<a class="anchor" id="a121e928e62bc7a8fafbfcb899422473b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int breplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace a section of a bstring from pos for a length len with the bstring b2.</p>
<p>If the position pos is past the end of b1 then the character "fill" is appended as necessary to make up the gap between the end of b1 and pos. </p>

</div>
</div>
<a class="anchor" id="a643afd7b892eac5f33da8b6e6ed7a370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int brtrimws </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete whitespace contiguous from the right end of the bstring.</p>
<p>This function will return with BSTR_ERR if b is NULL or of length 0, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="acc9f3dd50c02178eda7af1f17af4d18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsbufflength </td>
          <td>(</td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the length of the buffer used by the bStream.</p>
<p>If sz is the macro BSTR_BS_BUFF_LENGTH_GET (which is 0), the length is not set. If s is NULL or sz is negative, the function will return with BSTR_ERR, otherwise this function returns with the previous length. </p>

</div>
</div>
<a class="anchor" id="ac3a4b83757a84cd7032f10ec1e7b384c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC void* bsclose </td>
          <td>(</td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the bStream, and return the handle to the stream that was originally used to open the given stream.</p>
<p>If s is NULL or detectably invalid, NULL will be returned. </p>

</div>
</div>
<a class="anchor" id="a934dd8c5862bc9a1a152f24581352729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bseof </td>
          <td>(</td>
          <td class="paramtype">const struct bStream *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the defacto "EOF" (end of file) state of a stream (1 if the bStream is in an EOF state, 0 if not, and BSTR_ERR if stream is closed or detectably erroneous).</p>
<p>When the readPtr callback returns a value &lt;= 0 the stream reaches its "EOF" state. Note that bunread with non-empty content will essentially turn off this state, and the stream will not be in its "EOF" state so long as its possible to read more data out of it.</p>
<p>Also note that the semantics of <a class="el" href="bstrlib_8h.html#a934dd8c5862bc9a1a152f24581352729">bseof()</a> are slightly different from something like feof(), i.e., reaching the end of the stream does not necessarily guarantee that <a class="el" href="bstrlib_8h.html#a934dd8c5862bc9a1a152f24581352729">bseof()</a> will return with a value indicating that this has happened. <a class="el" href="bstrlib_8h.html#a934dd8c5862bc9a1a152f24581352729">bseof()</a> will only return indicating that it has reached the "EOF" and an attempt has been made to read past the end of the bStream. </p>

</div>
</div>
<a class="anchor" id="a9e08bbf1ea2ba29c6a4aea6e22d4aa2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsetstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwrite the bstring b0 starting at position pos with the bstring b1.</p>
<p>If the position pos is past the end of b0, then the character "fill" is appended as necessary to make up the gap between the end of b0 and pos. If b1 is NULL, it behaves as if it were a 0-length bstring. The value BSTR_OK is returned if the operation is successful, otherwise BSTR_ERR is returned. </p>

</div>
</div>
<a class="anchor" id="afb96b6b63301b1ebcca743d3089a38af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC struct bStream* bsopen </td>
          <td>(</td>
          <td class="paramtype">bNread&#160;</td>
          <td class="paramname"><em>readPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrap a given open stream (described by a fread compatible function pointer and stream handle) into an open bStream suitable for the bstring library streaming functions. </p>

</div>
</div>
<a class="anchor" id="a114e0702414bc301d1fffb3468a4566c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bspeek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of currently buffered characters from the bStream that will be read prior to reads from the core stream, and append it to the the parameter r. </p>

</div>
</div>
<a class="anchor" id="a09dfbbd9ceb54609674f93efb2ef4270"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC struct <a class="el" href="structbstrList.html">bstrList</a>* bsplit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>splitChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an array of sequential substrings from str divided by the character splitChar.</p>
<p>Successive occurrences of the splitChar will be divided by empty bstring entries, following the semantics from the Python programming language. To reclaim the memory from this output structure, <a class="el" href="bstrlib_8h.html#ac4ce2eab1bc5a9e47dfd27bd33945de6">bstrListDestroy()</a> should be called. See <a class="el" href="bstrlib_8h.html#ac8256fd68b32e1f855d8663c2ba9673f">bstrListCreate()</a> above for structure of struct <a class="el" href="structbstrList.html">bstrList</a>. </p>

</div>
</div>
<a class="anchor" id="ab171b3a636cbff169c621f411b716ae5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsplitcb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>splitChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *parm, int ofs, int len)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate the set of disjoint sequential substrings over str starting at position pos divided by the character splitChar.</p>
<p>The parm passed to bsplitcb is passed on to cb. If the function cb returns a value &lt; 0, then further iterating is halted and this value is returned by bsplitcb.</p>
<p>Note: Non-destructive modification of str from within the cb function while performing this split is not undefined. bsplitcb behaves in sequential lock step with calls to cb. I.e., after returning from a cb that return a non-negative integer, bsplitcb continues from the position 1 character after the last detected split character and it will halt immediately if the length of str falls below this point. However, if the cb function destroys str, then it <em>must</em> return with a negative value, otherwise bsplitcb will continue in an undefined manner.</p>
<p>This function is provided as an incremental alternative to bsplit that is abortable and which does not impose additional memory allocation. </p>

</div>
</div>
<a class="anchor" id="a0d3643d53f502cd0a82601f555b9d793"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC struct <a class="el" href="structbstrList.html">bstrList</a>* bsplits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>splitStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an array of sequential substrings from str divided by any character contained in splitStr.</p>
<p>An empty splitStr causes a single entry <a class="el" href="structbstrList.html">bstrList</a> containing a copy of str to be returned. See <a class="el" href="bstrlib_8h.html#ac8256fd68b32e1f855d8663c2ba9673f">bstrListCreate()</a> above for structure of struct <a class="el" href="structbstrList.html">bstrList</a>. </p>

</div>
</div>
<a class="anchor" id="aa7e0d102ee1fc760655184e1a7fe92bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsplitscb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>splitStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *parm, int ofs, int len)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate the set of disjoint sequential substrings over str starting at position pos divided by any of the characters in splitStr.</p>
<p>An empty splitStr causes the whole str to be iterated once. The parm passed to bsplitcb is passed on to cb. If the function cb returns a value &lt; 0, then further iterating is halted and this value is returned by bsplitcb.</p>
<p>Note: Non-destructive modification of str from within the cb function while performing this split is not undefined. bsplitscb behaves in sequential lock step with calls to cb. I.e., after returning from a cb that return a non-negative integer, bsplitscb continues from the position 1 character after the last detected split character and it will halt immediately if the length of str falls below this point. However, if the cb function destroys str, then it <em>must</em> return with a negative value, otherwise bsplitscb will continue in an undefined manner.</p>
<p>This function is provided as an incremental alternative to bsplits that is abortable and which does not impose additional memory allocation. </p>

</div>
</div>
<a class="anchor" id="ade8901b6979be1225005535b62fcbd43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC struct <a class="el" href="structbstrList.html">bstrList</a>* bsplitstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>splitStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an array of sequential substrings from str divided by the entire substring splitStr.</p>
<p>An empty splitStr causes a single entry <a class="el" href="structbstrList.html">bstrList</a> containing a copy of str to be returned. See <a class="el" href="bstrlib_8h.html#ac8256fd68b32e1f855d8663c2ba9673f">bstrListCreate()</a> above for structure of struct <a class="el" href="structbstrList.html">bstrList</a>. </p>

</div>
</div>
<a class="anchor" id="a88c47aea4543afeeb3831656c65bae59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsplitstrcb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>splitStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *parm, int ofs, int len)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate the set of disjoint sequential substrings over str starting at position pos divided by the entire substring splitStr.</p>
<p>An empty splitStr causes each character of str to be iterated. The parm passed to bsplitcb is passed on to cb. If the function cb returns a value &lt; 0, then further iterating is halted and this value is returned by bsplitcb.</p>
<p>Note: Non-destructive modification of str from within the cb function while performing this split is not undefined. bsplitstrcb behaves in sequential lock step with calls to cb. I.e., after returning from a cb that return a non-negative integer, bsplitstrcb continues from the position 1 character after the last detected split character and it will halt immediately if the length of str falls below this point. However, if the cb function destroys str, then it <em>must</em> return with a negative value, otherwise bsplitscb will continue in an undefined manner.</p>
<p>This function is provided as an incremental alternative to bsplitstr that is abortable and which does not impose additional memory allocation. </p>

</div>
</div>
<a class="anchor" id="afd0dd2679b0d4d63086c9ec53dbba665"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a bstring of length n (or, if it is fewer, as many bytes as is remaining) from the bStream.</p>
<p>This function will read the minimum required number of additional characters from the core stream. When the stream is at the end of the file BSTR_ERR is returned, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="a3cfbec9ee41315deab3302c66e2fc5ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsreada </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a bstring of length n (or, if it is fewer, as many bytes as is remaining) from the bStream and concatenate it to the parameter r.</p>
<p>This function will read the minimum required number of additional characters from the core stream. When the stream is at the end of the file BSTR_ERR is returned, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="a4b80e0c978896f52491202e8451f8025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsreadln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a bstring terminated by the terminator character or the end of the stream from the bStream (s) and return it into the parameter r.</p>
<p>The matched terminator, if found, appears at the end of the line read. If the stream has been exhausted of all available data, before any can be read, BSTR_ERR is returned. This function may read additional characters into the stream buffer from the core stream that are not returned, but will be retained for subsequent read operations. When reading from high speed streams, this function can perform significantly faster than bgets. </p>

</div>
</div>
<a class="anchor" id="ad7cebb47e8b79dc359f6bfae98a24363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsreadlna </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a bstring terminated by the terminator character or the end of the stream from the bStream (s) and concatenate it to the parameter r.</p>
<p>The matched terminator, if found, appears at the end of the line read. If the stream has been exhausted of all available data, before any can be read, BSTR_ERR is returned. This function may read additional characters into the stream buffer from the core stream that are not returned, but will be retained for subsequent read operations. When reading from high speed streams, this function can perform significantly faster than bgets. </p>

</div>
</div>
<a class="anchor" id="a3d83d2449e4b13dbead049f93a1fce24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsreadlns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>term</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a bstring terminated by any character in the terminators bstring or the end of the stream from the bStream (s) and return it into the parameter r.</p>
<p>This function may read additional characters from the core stream that are not returned, but will be retained for subsequent read operations. </p>

</div>
</div>
<a class="anchor" id="a7dec273a7c9f2468c64356b07e24d213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsreadlnsa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>term</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a bstring terminated by any character in the terminators bstring or the end of the stream from the bStream (s) and concatenate it to the parameter r.</p>
<p>If the stream has been exhausted of all available data, before any can be read, BSTR_ERR is returned. This function may read additional characters from the core stream that are not returned, but will be retained for subsequent read operations. </p>

</div>
</div>
<a class="anchor" id="a710fdfb5235a8c244a9b05db5b2c802f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bssplitscb </td>
          <td>(</td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>splitStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *parm, int ofs, const <a class="el" href="structtagbstring.html">bstring</a> entry)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate the set of disjoint sequential substrings over the stream s divided by any character from the bstring splitStr.</p>
<p>The parm passed to bssplitscb is passed on to cb. If the function cb returns a value &lt; 0, then further iterating is halted and this return value is returned by bssplitscb.</p>
<p>Note: At the point of calling the cb function, the bStream pointer is pointed exactly at the position right after having read the split character. The cb function can act on the stream by causing the bStream pointer to move, and bssplitscb will continue by starting the next split at the position of the pointer after the return from cb.</p>
<p>However, if the cb causes the bStream s to be destroyed then the cb must return with a negative value, otherwise bssplitscb will continue in an undefined manner.</p>
<p>This function is provided as way to incrementally parse through a file or other generic stream that in total size may otherwise exceed the practical or desired memory available. As with the other split callback based functions this is abortable and does not impose additional memory allocation. </p>

</div>
</div>
<a class="anchor" id="ae866c8b53b094dac5bb52b03b5004a7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bssplitstrcb </td>
          <td>(</td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>splitStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *parm, int ofs, const <a class="el" href="structtagbstring.html">bstring</a> entry)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate the set of disjoint sequential substrings over the stream s divided by the entire substring splitStr.</p>
<p>The parm passed to bssplitstrcb is passed on to cb. If the function cb returns a value &lt; 0, then further iterating is halted and this return value is returned by bssplitstrcb.</p>
<p>Note: At the point of calling the cb function, the bStream pointer is pointed exactly at the position right after having read the split character. The cb function can act on the stream by causing the bStream pointer to move, and bssplitstrcb will continue by starting the next split at the position of the pointer after the return from cb.</p>
<p>However, if the cb causes the bStream s to be destroyed then the cb must return with a negative value, otherwise bssplitscb will continue in an undefined manner.</p>
<p>This function is provided as way to incrementally parse through a file or other generic stream that in total size may otherwise exceed the practical or desired memory available. As with the other split callback based functions this is abortable and does not impose additional memory allocation. </p>

</div>
</div>
<a class="anchor" id="a8333d17de053dc35dc306ff347c4a167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC char* bstr2cstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a '\0' terminated char buffer which contains the contents of the bstring s, except that any contained '\0' characters are converted to the character in z.</p>
<p>This returned value should be freed with <a class="el" href="bstrlib_8h.html#a3f493957027d9cb58a87dbe611975564">bcstrfree()</a>, by the caller. If an error occurs NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a26209ea604a59389a452ad1c02f24c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bstrchrp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the character c in b forwards from the position pos (inclusive).</p>
<p>Returns the position of the found character or BSTR_ERR if it is not found. </p>

</div>
</div>
<a class="anchor" id="a1c60dfeb06b3dc86a00a81da00474ca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bstrcmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare the bstrings b0 and b1 for ordering.</p>
<p>If there is an error, SHRT_MIN is returned, otherwise a value less than or greater than zero, indicating that the bstring pointed to by b0 is lexicographically less than or greater than the bstring pointed to by b1 is returned. If the bstring lengths are unequal but the characters up until the length of the shorter are equal then a value less than, or greater than zero, indicating that the bstring pointed to by b0 is shorter or longer than the bstring pointed to by b1 is returned. 0 is returned if and only if the two bstrings are the same. If the length of the bstrings are different, this function is O(n). Like its standard C library counter part, the comparison does not proceed past any '\0' termination characters encountered.</p>
<p>The seemingly odd error return value, merely provides slightly more granularity than the undefined situation given in the C library function strcmp. The function otherwise behaves very much like strcmp().</p>
<p>Note that the semantics of bstrcmp are not completely compatible with biseq because of its different treatment of the '\0' termination character. </p>

</div>
</div>
<a class="anchor" id="a8f9a9d2432e61127eb204c0bffbb7133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC <a class="el" href="structtagbstring.html">bstring</a> bstrcpy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a copy of the passed in bstring.</p>
<p>The copied bstring is returned if there is no error, otherwise NULL is returned. </p>

</div>
</div>
<a class="anchor" id="a8b87ba679b2cf2796b412e77d9db153c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bstricmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two bstrings without differentiating between case.</p>
<p>The return value is the difference of the values of the characters where the two bstrings first differ, otherwise 0 is returned indicating that the bstrings are equal. If the lengths are different, then a difference from 0 is given, but if the first extra character is '\0', then it is taken to be the value UCHAR_MAX + 1. </p>

</div>
</div>
<a class="anchor" id="a29c49a96028195353c1f77da89956374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bstrListAlloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstrList.html">bstrList</a> *&#160;</td>
          <td class="paramname"><em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure that there is memory for at least msz number of entries for the list. </p>

</div>
</div>
<a class="anchor" id="abfc9093af717dc10707db3028b0537ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bstrListAllocMin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstrList.html">bstrList</a> *&#160;</td>
          <td class="paramname"><em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to allocate the minimum amount of memory for the list to include at least msz entries or sl-&gt;qty whichever is greater. </p>

</div>
</div>
<a class="anchor" id="ac8256fd68b32e1f855d8663c2ba9673f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC struct <a class="el" href="structbstrList.html">bstrList</a>* bstrListCreate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an empty struct <a class="el" href="structbstrList.html">bstrList</a>.</p>
<p>The struct <a class="el" href="structbstrList.html">bstrList</a> output structure is declared as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structbstrList.html">bstrList</a> {</div>
<div class="line">    <span class="keywordtype">int</span> qty, mlen;</div>
<div class="line">    <a class="code" href="structtagbstring.html">bstring</a> *entry;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The entry field actually is an array with qty number entries. The mlen record counts the maximum number of bstring's for which there is memory in the entry record.</p>
<p>The Bstrlib API does <em>NOT</em> include a comprehensive set of functions for full management of struct <a class="el" href="structbstrList.html">bstrList</a> in an abstracted way. The reason for this is because aliasing semantics of the list are best left to the user of this function, and performance varies wildly depending on the assumptions made. </p>

</div>
</div>
<a class="anchor" id="ac4ce2eab1bc5a9e47dfd27bd33945de6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bstrListDestroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbstrList.html">bstrList</a> *&#160;</td>
          <td class="paramname"><em>sl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a struct <a class="el" href="structbstrList.html">bstrList</a> structure that was returned by the bsplit function. Note that this will destroy each bstring in the -&gt;entry array as well. See <a class="el" href="bstrlib_8h.html#ac8256fd68b32e1f855d8663c2ba9673f">bstrListCreate()</a> above for structure of struct <a class="el" href="structbstrList.html">bstrList</a>. </p>

</div>
</div>
<a class="anchor" id="aecc2d64746f37d59ca588a569339a670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bstrncmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare the bstrings b0 and b1 for ordering for at most n characters.</p>
<p>If there is an error, SHRT_MIN is returned, otherwise a value is returned as if b0 and b1 were first truncated to at most n characters then bstrcmp was called with these new bstrings are paremeters. If the length of the bstrings are different, this function is O(n). Like its standard C library counter part, the comparison does not proceed past any '\0' termination characters encountered.</p>
<p>The seemingly odd error return value, merely provides slightly more granularity than the undefined situation given in the C library function strncmp. The function otherwise behaves very much like strncmp(). </p>

</div>
</div>
<a class="anchor" id="a1e904639bb6ff4caba5696d697460c8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bstrnicmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two bstrings without differentiating between case for at most n characters.</p>
<p>If the position where the two bstrings first differ is before the nth position, the return value is the difference of the values of the characters, otherwise 0 is returned. If the lengths are different and less than n characters, then a difference from 0 is given, but if the first extra character is '\0', then it is taken to be the value UCHAR_MAX + 1. </p>

</div>
</div>
<a class="anchor" id="a7f3e67d89be749a1d2e5ffede2d6f29c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bstrrchrp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the character c in b backwards from the position pos in bstring (inclusive).</p>
<p>Returns the position of the found character or BSTR_ERR if it is not found. </p>

</div>
</div>
<a class="anchor" id="a1269da6e6bb75f5a0fd4529cab74ef6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bsunread </td>
          <td>(</td>
          <td class="paramtype">struct bStream *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a bstring into the bStream at the current position.</p>
<p>These characters will be read prior to those that actually come from the core stream. </p>

</div>
</div>
<a class="anchor" id="a471ebb4ce64f26dc634470c787ad0e8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int btolower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert contents of bstring to lower case.</p>
<p>This function will return with BSTR_ERR if b is NULL or of length 0, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="a636e5fbffa44bb54ca24342eab6ef016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int btoupper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert contents of bstring to upper case.</p>
<p>This function will return with BSTR_ERR if b is NULL or of length 0, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="ac4f230982ef4fc45d8d3b9847fe94802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int btrimws </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete whitespace contiguous from both ends of the bstring.</p>
<p>This function will return with BSTR_ERR if b is NULL or of length 0, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="a91a8464aba37a4b8a1ff20b9969798af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int btrunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate the bstring to at most n characters.</p>
<p>This function will return with BSTR_ERR if b is not detected as a valid bstring or n is less than 0, otherwise BSTR_OK is returned. </p>

</div>
</div>
<a class="anchor" id="a6435bf68d7a8ea9a1c73c4b4c3358005"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BSTR_PUBLIC int bvcformata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtagbstring.html">bstring</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The bvcformata function formats data under control of the format control string fmt and attempts to append the result to b.</p>
<p>The fmt parameter is the same as that of the printf function. The variable argument list is replaced with arglist, which has been initialized by the va_start macro. The size of the output is upper bounded by count. If the required output exceeds count, the string b is not augmented with any contents and a value below BSTR_ERR is returned. If a value below -count is returned then it is recommended that the negative of this value be used as an update to the count in a subsequent pass. On other errors, such as running out of memory, parameter errors or numeric wrap around BSTR_ERR is returned. BSTR_OK is returned when the output is successfully generated and appended to b.</p>
<p>Note: There is no sanity checking of arglist, and this function is destructive of the contents of b from the b-&gt;slen point onward. If there is an early generation of a '\0' character, the bstring will be truncated to this end point.</p>
<p>Although this function is part of the external API for Bstrlib, the interface and semantics (length limitations, and unusual return codes) are fairly atypical. The real purpose for this function is to provide an engine for the bvformata macro. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 9 2013 10:31:59 for bstring by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
